/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright(c) 2022 Sanpe <sanpeqf@gmail.com>
 */

#include <errname.h>
#include <kernel.h>
#include <bsearch.h>
#include <export.h>

struct errname_entry {
    state errno;
    const char *name;
};

#define ERRNAME(errno) {errno, #errno}
static const struct errname_entry errname_array[] = {
    ERRNAME(ENOERR),
    ERRNAME(EPERM),
    ERRNAME(ENOENT),
    ERRNAME(ESRCH),
    ERRNAME(EINTR),
    ERRNAME(EIO),
    ERRNAME(ENXIO),
    ERRNAME(E2BIG),
    ERRNAME(ENOEXEC),
    ERRNAME(EBADF),
    ERRNAME(ECHILD),
    ERRNAME(EAGAIN),
    ERRNAME(ENOMEM),
    ERRNAME(EACCES),
    ERRNAME(EFAULT),
    ERRNAME(ENOTBLK),
    ERRNAME(EBUSY),
    ERRNAME(EEXIST),
    ERRNAME(EXDEV),
    ERRNAME(ENODEV),
    ERRNAME(ENOTDIR),
    ERRNAME(EISDIR),
    ERRNAME(EINVAL),
    ERRNAME(ENFILE),
    ERRNAME(EMFILE),
    ERRNAME(ENOTTY),
    ERRNAME(ETXTBSY),
    ERRNAME(EFBIG),
    ERRNAME(ENOSPC),
    ERRNAME(ESPIPE),
    ERRNAME(EROFS),
    ERRNAME(EMLINK),
    ERRNAME(EPIPE),
    ERRNAME(EDOM),
    ERRNAME(ERANGE),

    ERRNAME(EDEADLK),
    ERRNAME(ENAMETOOLONG),
    ERRNAME(ENOLCK),
    ERRNAME(ENOSYS),
    ERRNAME(EBFONT),
    ERRNAME(ENOSTR),
    ERRNAME(ENODATA),
    ERRNAME(ETIME),
    ERRNAME(ENOSR),
    ERRNAME(ENONET),
    ERRNAME(ENOPKG),
    ERRNAME(EREMOTE),
    ERRNAME(ENOLINK),
    ERRNAME(EADV),
    ERRNAME(ESRMNT),
    ERRNAME(ECOMM),
    ERRNAME(EPROTO),
    ERRNAME(EMULTIHOP),
    ERRNAME(EDOTDOT),
    ERRNAME(EBADMSG),
    ERRNAME(EOVERFLOW),
    ERRNAME(ENOTUNIQ),
    ERRNAME(EBADFD),
    ERRNAME(EREMCHG),
    ERRNAME(ELIBACC),
    ERRNAME(ELIBBAD),
    ERRNAME(ELIBSCN),
    ERRNAME(ELIBMAX),
    ERRNAME(ELIBEXEC),
    ERRNAME(EILSEQ),
    ERRNAME(ERESTART),
    ERRNAME(ESTRPIPE),
    ERRNAME(EUSERS),
    ERRNAME(ENOTSOCK),
    ERRNAME(EDESTADDRREQ),
    ERRNAME(EMSGSIZE),
    ERRNAME(EPROTOTYPE),
    ERRNAME(ENOPROTOOPT),
    ERRNAME(EPROTONOSUPPORT),
    ERRNAME(ESOCKTNOSUPPORT),
    ERRNAME(EOPNOTSUPP),
    ERRNAME(EPFNOSUPPORT),
    ERRNAME(EAFNOSUPPORT),
    ERRNAME(EADDRINUSE),
    ERRNAME(EADDRNOTAVAIL),
    ERRNAME(ENETDOWN),
    ERRNAME(ENETUNREACH),
    ERRNAME(ENETRESET),
    ERRNAME(ECONNABORTED),
    ERRNAME(ECONNRESET),
    ERRNAME(ENOBUFS),
    ERRNAME(EISCONN),
    ERRNAME(ENOTCONN),
    ERRNAME(ESHUTDOWN),
    ERRNAME(ETOOMANYREFS),
    ERRNAME(ETIMEDOUT),
    ERRNAME(ECONNREFUSED),
    ERRNAME(EHOSTDOWN),
    ERRNAME(EHOSTUNREACH),
    ERRNAME(EALREADY),
    ERRNAME(EINPROGRESS),
    ERRNAME(ESTALE),
    ERRNAME(EUCLEAN),
    ERRNAME(ENOTNAM),
    ERRNAME(ENAVAIL),
    ERRNAME(EISNAM),
    ERRNAME(EREMOTEIO),
    ERRNAME(EDQUOT),
    ERRNAME(ENOMEDIUM),
    ERRNAME(EMEDIUMTYPE),
    ERRNAME(ECANCELED),
    ERRNAME(ENOKEY),
    ERRNAME(EKEYEXPIRED),
    ERRNAME(EKEYREVOKED),
    ERRNAME(EKEYREJECTED),

    ERRNAME(ERESTARTSYS),
    ERRNAME(ERESTARTNOINTR),
    ERRNAME(ERESTARTNOHAND),
    ERRNAME(ENOIOCTLCMD),
    ERRNAME(ERESTART_RESTARTBLOCK),
    ERRNAME(EPROBE_DEFER),
    ERRNAME(EOPENSTALE),
    ERRNAME(ENOPARAM),
    ERRNAME(EBADHANDLE),
    ERRNAME(ENOTSYNC),
    ERRNAME(EBADCOOKIE),
    ERRNAME(ENOTSUPP),
    ERRNAME(ETOOSMALL),
    ERRNAME(ESERVERFAULT),
    ERRNAME(EBADTYPE),
    ERRNAME(EJUKEBOX),
    ERRNAME(EIOCBQUEUED),
    ERRNAME(ERECALLCONFLICT),
    ERRNAME(ENOGRACE),
};

static long errname_search(const void *key, void *pdata)
{
    const struct errname_entry *entry = key;
    return entry->errno - (state)pdata;
}

const char *errname(state error)
{
    struct errname_entry *entry;

    if (unlikely(error > 0))
        return NULL;

    entry = bsearch(
        errname_array, ARRAY_SIZE(errname_array),
        sizeof(*entry), errname_search, (void *)-error
    );

    return entry ? entry->name : NULL;
}
EXPORT_SYMBOL(errname);
