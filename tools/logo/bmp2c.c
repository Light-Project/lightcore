/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright(c) 2022 John Sanpe <sanpeqf@gmail.com>
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <endian.h>

#if BYTE_ORDER == LITTLE_ENDIAN
#define le16_to_cpu(val) (val)
#define le32_to_cpu(val) (val)
#define le64_to_cpu(val) (val)
#endif
#if BYTE_ORDER == BIG_ENDIAN
#define le16_to_cpu(val) __bswap_16(val)
#define le32_to_cpu(val) __bswap_32(val)
#define le64_to_cpu(val) __bswap_64(val)
#endif

struct bmp_file {
    uint16_t magic;
    uint32_t size;
    uint16_t reserved[2];
    uint32_t offset;
} __attribute__((__packed__));

struct bmp_info {
    uint32_t hdsize;
    uint32_t width;
    uint32_t hight;
    uint16_t planes;
    uint16_t bitcount;
    uint32_t compre;
    uint32_t size;
    uint32_t xppm;
    uint32_t yppm;
    uint32_t colour;
    uint32_t clrmsk;
} __attribute__((__packed__));

struct bmp_head {
    struct bmp_file file;
    struct bmp_info info;
} __attribute__((__packed__));

static void usage(void)
{
    printf("usage: bmp2c [option] <filename>\n");
    printf("\t-n  logoname\n");
    printf("\t-o  filename\n");
    printf("\t-h  display this message\n");
}

static inline void write_hex(FILE *out, unsigned int hexcnt, uint8_t byte)
{
    if (!hexcnt)
        fprintf(out, "\t0x%02x", byte);
    else if (hexcnt % 12)
        fprintf(out, ", 0x%02x", byte);
    else
        fprintf(out, ",\n\t0x%02x", byte);
}

static void write_logo(FILE *out, const char *logoname, struct bmp_head *bmp)
{
    unsigned int count, hexcnt = 0;
    uint32_t size;
    uint8_t *data;

    size = le32_to_cpu(bmp->info.size);
    data = (void *)bmp + le32_to_cpu(bmp->file.offset);

    fprintf(out, "static unsigned char %s_data[] = {\n", logoname);
    for (count = 0; count < size; ++count)
        write_hex(out, hexcnt++, *data++);
    fputs("\n};\n\n", out);
}

static void write_header(FILE *out, const char *filename)
{
    fputs("/*\n", out);
    fputs(" *  DO NOT EDIT THIS FILE!\n", out);
    fputs(" *\n", out);
    fprintf(out, " *  It was automatically generated from %s\n", filename);
    fputs(" *\n", out);
    fputs(" */\n\n", out);
    fputs("#include <logo.h>\n\n", out);
}

static void write_info(FILE *output, const char *logoname, struct bmp_info *info)
{
    fprintf(output, "const struct logo %s_info = {\n", logoname);
    fprintf(output, "\t.name = \"%s\",\n", logoname);
    fprintf(output, "\t.width = %d,\n", le32_to_cpu(info->width));
    fprintf(output, "\t.height = %d,\n", le32_to_cpu(info->hight));
    fprintf(output, "\t.colour = %d,\n", le32_to_cpu(info->colour) ?: 32);
    fprintf(output, "\t.data = %s_data\n", logoname);
    fputs("};\n", output);
}

int main(int argc, char *argv[])
{
    FILE *input, *output = stdout;
    char *newfile = NULL, *logo = "logo";
    struct bmp_head *bmp;
    unsigned int count;
    size_t size;

    for (count = 1; count < argc; ++count) {
        char *para = argv[count];

        if (para[0] != '-')
            break;

        switch (para[1]) {
            case 'o':
                if ((++count) >= argc)
                    goto usage;
                newfile = argv[count];
                break;

            case 'n':
                if ((++count) >= argc)
                    goto usage;
                logo = argv[count];
                break;

            default:
                goto usage;
        }
    }

    if (argc == count)
        goto usage;

    input = fopen(argv[count], "rb");
    if (!input) {
        perror("can not open input file");
        goto usage;
    }

    fseek(input, SEEK_SET, SEEK_END);
    size = ftell(input);

    bmp = malloc(size);
    if (!bmp) {
        perror("insufficient memory\n");
        goto usage;
    }

    fseek(input, 0, SEEK_SET);
    fread(bmp, size, 1, input);
    fclose(input);

    if (le16_to_cpu(bmp->file.magic) != 0x4d42) {
        perror("file format error\n");
        goto usage;
    }

    if (le32_to_cpu(bmp->info.compre) != 3) {
        perror("compressed bmp not supported\n");
        goto usage;
    }

    if (newfile) {
        output = fopen(newfile, "wb");
        if (!output) {
            perror("can not create output file");
            goto usage;
        }
    }

    write_header(output, argv[count]);
    write_logo(output, logo, bmp);
    write_info(output, logo, &bmp->info);

    fclose(output);

    return 0;

usage:
    usage();
    return -EINVAL;
}
